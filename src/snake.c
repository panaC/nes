#include <stdio.h>
#include "snake.h"
#include "stdint.h"
#include "utils.h"
#include "sdl.h"
#include "debug.h"
#include "cpu.h"

#define debug(...) log_x(LOG_DEBUG, __VA_ARGS__)

uint8_t rom[] = {
  0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
  0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
  0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
  0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
  0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
  0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
  0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
  0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
  0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
  0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
  0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
  0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
  0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
  0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
  0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
  0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
  0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
  0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
  0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
  0xea, 0xca, 0xd0, 0xfb, 0x60, 0x00, // game-over
};

#define START 0x600
static int quit = 0;
static char lastkeycode = 0;
static uint32_t rawPixel[SNAKE_WIDTH * SNAKE_HEIGHT] = {0};

// extern global var
char __pause = 1; // pause at startup

static void setPixelWithPitch(uint32_t pos, uint32_t color) {
  uint32_t pixel;
  if (pos < (SNAKE_WIDTH * SNAKE_HEIGHT) / (SNAKE_PITCH * SNAKE_PITCH)) {
    for (int i = 0; i < SNAKE_PITCH; i++) {
      for (int j = 0; j < SNAKE_PITCH; j++) {
        pixel = (pos / (SNAKE_WIDTH / SNAKE_PITCH) * SNAKE_PITCH * SNAKE_WIDTH + i * SNAKE_WIDTH) + pos % (SNAKE_HEIGHT / SNAKE_PITCH) * SNAKE_PITCH + j;
        rawPixel[pixel] = color;
      }
    }
  }
}

static t_snake_action sdl_processEvent() {
  SDL_Event event;
  t_snake_action ret;

  SDL_PollEvent(&event);
  switch (event.type)
  {
  case SDL_QUIT:
    debug("QUIT EVENT");
    return QUIT_EVENT;
    break;

  case SDL_KEYDOWN:
				switch (event.key.keysym.sym) {
					case SDLK_LEFT:
						return MOVE_LEFT;
						break;
					case SDLK_RIGHT:
						return MOVE_RIGHT;
						break;
					case SDLK_DOWN:
						return MOVE_DOWN;
						break;
					case SDLK_UP:
						return MOVE_UP;
						break;
					case SDLK_RETURN:
						return PAUSE;
						break;
				}
				break;

  default:
    // debug("UNKNOWN EVENT %d", event.type);
    return NO_EVENT;
  }

  return NO_EVENT;
}

uint8_t bus_read_fe_rand(uint8_t value, uint32_t addr) {
  if (addr == 0xfe) {
    value =  rand() % 256;
    debug("BUS: rand value %d", value);
  }
  return value;
}

uint8_t bus_read_ff_rand(uint8_t value, uint32_t addr) {
  if (addr == 0xff) {
    value = lastkeycode;
    debug("BUS: last key %d", value);
  }
  return value;
}

uint8_t bus_write_2xx_screen(uint8_t value, uint32_t addr) {
  if (addr >= 0x200 && addr < 0x600) {
    // fill a rect at address to the screen
    setPixelWithPitch(addr - 0x200, value ? 0xffffffff : 0);
    debug("SET PIXEL X=%d Y=%d", (addr-0x200) % 32, (addr-0x200) / 32);
  }
  return value;
}

void snake_init() {

  uint8_t *rawmem = (uint8_t *)malloc(MEM_SIZE);
  bzero(rawmem, MEM_SIZE);
  for (int i = 0; i < MEM_SIZE; i++) {
    __cpu_memory[i] = rawmem + i;
  }

  for(int i = 0; i < sizeof(rom); i++) {
    __cpu_memory[START + i] = rom + i;
  }

  union u16 resetVector = {.value = START};

  *__cpu_memory[0xfffc] = resetVector.lsb;
  *__cpu_memory[0xfffd] = resetVector.msb;

  // hexdump(*(__cpu_memory + START), 320);

  cpu_write_on(&bus_write_2xx_screen);
  cpu_read_on(&bus_read_fe_rand);
  cpu_read_on(&bus_read_ff_rand);
}

void snake() {

  // memory map
  // 0x000 -> 0x0ff : variable
  // 0x100 -> 0x1ff : stack
  // 0x200 -> 0x5ff : screen 32 * 32
  // 0x600 -> sizeof(rom) : rom
  // memory_size = 0x1000 : 16 * 256 : 4kB

  int quit = 0;

  while (quit != -1)
  {

    switch (sdl_processEvent())
    {
    case QUIT_EVENT:
      quit = -1;
      break;
    case MOVE_DOWN:
      lastkeycode = 0x73;
      debug("MOVE DOWN");
      break;
    case MOVE_UP:
      lastkeycode = 0x77;
      debug("MOVE UP");
      break;
    case MOVE_LEFT:
      lastkeycode = 0x61;
      debug("MOVE LEFT");
      break;
    case MOVE_RIGHT:
      lastkeycode = 0x64;
      debug("MOVE RIGHT");
      break;
    case PAUSE:
      __pause = !__pause;
      debug("PAUSE");
      break;

    default:
      break;
    }

    SDL_Delay(1000 / 60); // 60fps
    sdl_showRendering(rawPixel, SNAKE_WIDTH);
  }

  // hexdumpSnake(*(__cpu_memory + 0x200), 1024);

}